"""
Module Clients SYSCOHADA pour WiseBook
Gestion avancée des clients selon EXF-CC-001 à EXF-CC-004
"""
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator, RegexValidator
from django.core.exceptions import ValidationError
from django.utils import timezone
from decimal import Decimal
import uuid
from datetime import date, timedelta

from apps.core.models import TimeStampedModel
from apps.accounting.models import Company, ChartOfAccounts, FiscalYear


class Customer(TimeStampedModel):
    """
    Modèle Client SYSCOHADA complet
    Conforme aux spécifications EXF-CC-001: Fichier Clients Enrichi
    """
    
    CUSTOMER_TYPE_CHOICES = [
        ('INDIVIDUAL', 'Particulier'),
        ('COMPANY', 'Entreprise'),
        ('ADMINISTRATION', 'Administration'),
        ('ASSOCIATION', 'Association'),
        ('FOREIGN', 'Client étranger'),
    ]
    
    LEGAL_FORM_CHOICES = [
        ('SA', 'Société Anonyme'),
        ('SARL', 'SARL'),
        ('SAS', 'SAS'),
        ('EI', 'Entreprise Individuelle'),
        ('GIE', 'GIE'),
        ('COOP', 'Coopérative'),
        ('ASSOC', 'Association'),
        ('OTHER', 'Autre'),
    ]
    
    PAYMENT_METHOD_CHOICES = [
        ('CASH', 'Espèces'),
        ('CHECK', 'Chèque'),
        ('TRANSFER', 'Virement'),
        ('DIRECT_DEBIT', 'Prélèvement'),
        ('CARD', 'Carte bancaire'),
        ('BILL', 'Traite'),
        ('MOBILE_MONEY', 'Mobile Money'),
    ]
    
    STATUS_CHOICES = [
        ('ACTIVE', 'Actif'),
        ('BLOCKED', 'Bloqué'),
        ('SUSPENDED', 'Suspendu'),
        ('PROSPECT', 'Prospect'),
        ('ARCHIVED', 'Archivé'),
    ]
    
    RISK_LEVEL_CHOICES = [
        ('A', 'Excellent (A)'),
        ('B', 'Bon (B)'),
        ('C', 'Moyen (C)'),
        ('D', 'Risqué (D)'),
        ('E', 'Très risqué (E)'),
    ]
    
    # Identifiants
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name='customers')
    
    # Code client selon cahier des charges: C + [Pays] + [Numéro séquentiel]
    code = models.CharField(
        max_length=20, 
        db_index=True,
        validators=[RegexValidator(r'^C[A-Z]{2}\d{5,}$', 'Format: CCM00001 (Client Cameroun 00001)')],
        help_text=\"Format: CCM00001 (Client Cameroun 00001)\"\n    )\n    \n    customer_type = models.CharField(max_length=20, choices=CUSTOMER_TYPE_CHOICES)\n    \n    # Données KYC Clients Complètes (EXF-CC-001)\n    legal_name = models.CharField(max_length=255, verbose_name=\"Raison sociale\")\n    commercial_name = models.CharField(max_length=255, blank=True, verbose_name=\"Nom commercial\")\n    legal_form = models.CharField(max_length=10, choices=LEGAL_FORM_CHOICES, blank=True)\n    \n    # Identification légale OHADA\n    rccm = models.CharField(max_length=50, blank=True, verbose_name=\"RCCM\")\n    nif = models.CharField(max_length=50, blank=True, verbose_name=\"NIF\")\n    taxpayer_number = models.CharField(max_length=50, blank=True, verbose_name=\"Numéro contribuable\")\n    vat_number = models.CharField(max_length=50, blank=True, verbose_name=\"Numéro TVA\")\n    \n    # Secteur d'activité et code NAF\n    business_sector = models.CharField(max_length=100, blank=True, verbose_name=\"Secteur d'activité\")\n    naf_code = models.CharField(max_length=10, blank=True, verbose_name=\"Code NAF\")\n    \n    # Adresses multi-sites (EXF-CC-001)\n    main_address = models.TextField(verbose_name=\"Adresse principale\")\n    city = models.CharField(max_length=100, verbose_name=\"Ville\")\n    region = models.CharField(max_length=100, blank=True, verbose_name=\"Région\")\n    country = models.CharField(max_length=50, default=\"Cameroun\", verbose_name=\"Pays\")\n    postal_code = models.CharField(max_length=10, blank=True, verbose_name=\"Code postal\")\n    \n    # Contact principal\n    main_phone = models.CharField(max_length=20, blank=True, verbose_name=\"Téléphone\")\n    mobile_phone = models.CharField(max_length=20, blank=True, verbose_name=\"Mobile\")\n    email = models.EmailField(blank=True, verbose_name=\"Email\")\n    website = models.URLField(blank=True, verbose_name=\"Site web\")\n    \n    # Paramètres Commerciaux Clients (EXF-CC-001)\n    payment_terms = models.PositiveIntegerField(\n        default=30,\n        validators=[MinValueValidator(0), MaxValueValidator(365)],\n        verbose_name=\"Conditions de paiement (0-90 jours)\"\n    )\n    \n    credit_limit = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        validators=[MinValueValidator(Decimal('0'))],\n        verbose_name=\"Limite de crédit dynamique\"\n    )\n    \n    early_payment_discount = models.DecimalField(\n        max_digits=5, decimal_places=2, default=Decimal('0'),\n        validators=[MinValueValidator(Decimal('0')), MaxValueValidator(Decimal('20'))],\n        verbose_name=\"Taux escompte paiement anticipé (%)\"\n    )\n    \n    preferred_payment_method = models.CharField(\n        max_length=20, choices=PAYMENT_METHOD_CHOICES, default='TRANSFER',\n        verbose_name=\"Mode de règlement privilégié\"\n    )\n    \n    billing_currency = models.CharField(max_length=3, choices=[\n        ('XAF', 'Franc CFA (CEMAC)'),\n        ('XOF', 'Franc CFA (UEMOA)'),\n        ('EUR', 'Euro'),\n        ('USD', 'Dollar US'),\n    ], default='XAF', verbose_name=\"Devise de facturation\")\n    \n    communication_language = models.CharField(max_length=5, choices=[\n        ('fr', 'Français'),\n        ('en', 'English'),\n    ], default='fr', verbose_name=\"Langue de communication\")\n    \n    # Conditions particulières de vente\n    special_conditions = models.TextField(blank=True, verbose_name=\"Conditions particulières\")\n    \n    # Scoring et Risk Management (EXF-CC-001)\n    credit_score = models.PositiveIntegerField(\n        default=500,\n        validators=[MinValueValidator(0), MaxValueValidator(1000)],\n        verbose_name=\"Score de crédit (0-1000)\",\n        help_text=\"Score calculé automatiquement\"\n    )\n    \n    risk_level = models.CharField(\n        max_length=1, choices=RISK_LEVEL_CHOICES, default='B',\n        verbose_name=\"Niveau de risque\"\n    )\n    \n    # Historique des retards de paiement\n    current_outstanding = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"Encours actuel\", editable=False\n    )\n    \n    average_payment_delay = models.PositiveIntegerField(\n        default=0, verbose_name=\"Retard moyen (jours)\", editable=False\n    )\n    \n    litigation_rate = models.DecimalField(\n        max_digits=5, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"Taux de litige (%)\", editable=False\n    )\n    \n    # Prédiction de risque par IA (EXF-CC-001)\n    ai_risk_prediction = models.CharField(max_length=20, choices=[\n        ('VERY_LOW', 'Très faible'),\n        ('LOW', 'Faible'),\n        ('MEDIUM', 'Moyen'),\n        ('HIGH', 'Élevé'),\n        ('CRITICAL', 'Critique'),\n    ], default='LOW', verbose_name=\"Prédiction IA\")\n    \n    ai_risk_score = models.DecimalField(\n        max_digits=5, decimal_places=2, default=Decimal('0'),\n        validators=[MinValueValidator(Decimal('0')), MaxValueValidator(Decimal('100'))],\n        verbose_name=\"Score IA (%)\"\n    )\n    \n    last_risk_calculation = models.DateTimeField(\n        null=True, blank=True, verbose_name=\"Dernière analyse risque\"\n    )\n    \n    # Compte comptable associé\n    account = models.ForeignKey(\n        ChartOfAccounts, on_delete=models.SET_NULL, null=True,\n        limit_choices_to={'account_class': '4', 'code__startswith': '41'},\n        related_name='customers', verbose_name=\"Compte client (41x)\"\n    )\n    \n    # Statut et contrôles\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='ACTIVE')\n    blocking_reason = models.TextField(blank=True, verbose_name=\"Motif de blocage\")\n    blocking_date = models.DateTimeField(null=True, blank=True)\n    blocked_by = models.ForeignKey(\n        'auth.User', on_delete=models.SET_NULL, null=True, blank=True,\n        related_name='blocked_customers'\n    )\n    \n    # Informations entreprise\n    capital_amount = models.DecimalField(\n        max_digits=20, decimal_places=2, null=True, blank=True,\n        validators=[MinValueValidator(Decimal('0'))],\n        verbose_name=\"Capital social\"\n    )\n    annual_turnover = models.DecimalField(\n        max_digits=20, decimal_places=2, null=True, blank=True,\n        validators=[MinValueValidator(Decimal('0'))],\n        verbose_name=\"CA annuel déclaré\"\n    )\n    employee_count = models.PositiveIntegerField(\n        null=True, blank=True, verbose_name=\"Nombre d'employés\"\n    )\n    \n    # Dates importantes\n    company_creation_date = models.DateField(null=True, blank=True, verbose_name=\"Date création\")\n    first_order_date = models.DateField(null=True, blank=True, verbose_name=\"Première commande\")\n    last_order_date = models.DateField(null=True, blank=True, verbose_name=\"Dernière commande\", editable=False)\n    last_payment_date = models.DateField(null=True, blank=True, verbose_name=\"Dernier paiement\", editable=False)\n    \n    # Métadonnées\n    notes = models.TextField(blank=True, verbose_name=\"Notes internes\")\n    tags = models.JSONField(default=list, blank=True, verbose_name=\"Tags\")\n    \n    class Meta:\n        db_table = 'customers'\n        unique_together = [('company', 'code')]\n        indexes = [\n            models.Index(fields=['company', 'status']),\n            models.Index(fields=['legal_name']),\n            models.Index(fields=['credit_score']),\n            models.Index(fields=['risk_level']),\n            models.Index(fields=['-last_order_date']),\n        ]\n        ordering = ['code']\n        verbose_name = \"Client\"\n        verbose_name_plural = \"Clients\"\n    \n    def __str__(self):\n        return f\"{self.code} - {self.legal_name}\"\n    \n    def clean(self):\n        super().clean()\n        \n        # Validation compte client obligatoire\n        if not self.account:\n            raise ValidationError(\"Un compte client (classe 41) est obligatoire\")\n        \n        # Validation format code client\n        if not self.code.startswith('C'):\n            raise ValidationError(\"Le code client doit commencer par 'C'\")\n    \n    @property\n    def display_name(self):\n        if self.commercial_name:\n            return f\"{self.legal_name} ({self.commercial_name})\"\n        return self.legal_name\n    \n    @property\n    def available_credit(self):\n        \"\"\"Crédit disponible = limite - encours\"\"\"\n        return max(Decimal('0'), self.credit_limit - self.current_outstanding)\n    \n    @property\n    def credit_utilization_rate(self):\n        \"\"\"Taux utilisation crédit en %\"\"\"\n        if self.credit_limit == 0:\n            return Decimal('0')\n        return (self.current_outstanding / self.credit_limit * 100).quantize(Decimal('0.1'))\n    \n    @property\n    def days_since_last_order(self):\n        \"\"\"Nombre de jours depuis dernière commande\"\"\"\n        if not self.last_order_date:\n            return None\n        return (date.today() - self.last_order_date).days\n    \n    def update_outstanding_balance(self):\n        \"\"\"\n        Met à jour l'encours client depuis les écritures non lettrées\n        Performance optimisée\n        \"\"\"\n        from django.db.models import Sum\n        from apps.accounting.models import JournalEntryLine\n        \n        if not self.account:\n            return\n        \n        # Calcul encours = solde débiteur non lettré du compte client\n        aggregates = JournalEntryLine.objects.filter(\n            account=self.account,\n            third_party=self,  # Référence vers ce client\n            entry__is_validated=True,\n            is_reconciled=False  # Non lettrées\n        ).aggregate(\n            total_debit=Sum('debit_amount') or Decimal('0'),\n            total_credit=Sum('credit_amount') or Decimal('0')\n        )\n        \n        outstanding = max(Decimal('0'), \n                         aggregates['total_debit'] - aggregates['total_credit'])\n        \n        if self.current_outstanding != outstanding:\n            self.current_outstanding = outstanding\n            self.save(update_fields=['current_outstanding'])\n        \n        return outstanding\n    \n    def calculate_dso(self, period_days: int = 90):\n        \"\"\"\n        Calcule le DSO (Days Sales Outstanding) du client\n        \"\"\"\n        from django.db.models import Sum\n        from apps.accounting.models import JournalEntryLine\n        \n        period_start = date.today() - timedelta(days=period_days)\n        \n        # CA sur la période (compte 70x)\n        sales_amount = JournalEntryLine.objects.filter(\n            third_party=self,\n            account__account_class='7',\n            entry__entry_date__gte=period_start,\n            entry__is_validated=True\n        ).aggregate(\n            total=Sum('credit_amount') or Decimal('0')\n        )['total']\n        \n        if sales_amount == 0:\n            return 0\n        \n        # DSO = (Encours / CA) * Période\n        dso = (self.current_outstanding / sales_amount * period_days).quantize(Decimal('0.1'))\n        return float(dso)\n    \n    def get_aging_analysis(self):\n        \"\"\"\n        Analyse par ancienneté des créances (Balance Âgée)\n        \"\"\"\n        from django.db.models import Sum, Case, When, Q\n        from apps.accounting.models import JournalEntryLine\n        \n        today = date.today()\n        \n        # Tranches d'ancienneté\n        aging = JournalEntryLine.objects.filter(\n            account=self.account,\n            third_party=self,\n            entry__is_validated=True,\n            is_reconciled=False\n        ).aggregate(\n            current=Sum(Case(\n                When(entry__entry_date__gte=today - timedelta(days=30), \n                     then='debit_amount'),\n                default=Decimal('0')\n            )) or Decimal('0'),\n            \n            days_30_60=Sum(Case(\n                When(Q(entry__entry_date__lt=today - timedelta(days=30)) &\n                     Q(entry__entry_date__gte=today - timedelta(days=60)),\n                     then='debit_amount'),\n                default=Decimal('0')\n            )) or Decimal('0'),\n            \n            days_60_90=Sum(Case(\n                When(Q(entry__entry_date__lt=today - timedelta(days=60)) &\n                     Q(entry__entry_date__gte=today - timedelta(days=90)),\n                     then='debit_amount'),\n                default=Decimal('0')\n            )) or Decimal('0'),\n            \n            over_90=Sum(Case(\n                When(entry__entry_date__lt=today - timedelta(days=90),\n                     then='debit_amount'),\n                default=Decimal('0')\n            )) or Decimal('0')\n        )\n        \n        total = sum(aging.values())\n        \n        return {\n            'current': float(aging['current']),\n            '30_60_days': float(aging['days_30_60']),\n            '60_90_days': float(aging['days_60_90']),\n            'over_90_days': float(aging['over_90']),\n            'total': float(total),\n            'percentages': {\n                'current': float(aging['current'] / total * 100) if total > 0 else 0,\n                '30_60': float(aging['days_30_60'] / total * 100) if total > 0 else 0,\n                '60_90': float(aging['days_60_90'] / total * 100) if total > 0 else 0,\n                'over_90': float(aging['over_90'] / total * 100) if total > 0 else 0,\n            }\n        }\n\n\nclass CustomerContact(TimeStampedModel):\n    \"\"\"\n    Contacts multiples avec rôles (EXF-CC-001)\n    Comptable/Acheteur/Direction\n    \"\"\"\n    \n    ROLE_CHOICES = [\n        ('CEO', 'Dirigeant/PDG'),\n        ('CFO', 'Directeur Financier'),\n        ('ACCOUNTANT', 'Comptable'),\n        ('BUYER', 'Acheteur'),\n        ('SALES', 'Responsable Ventes'),\n        ('TECHNICAL', 'Contact Technique'),\n        ('LEGAL', 'Juridique'),\n        ('OTHER', 'Autre'),\n    ]\n    \n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='contacts')\n    \n    # Informations personnelles\n    title = models.CharField(max_length=10, choices=[\n        ('MR', 'M.'),\n        ('MS', 'Mme'),\n        ('DR', 'Dr'),\n    ], blank=True)\n    \n    first_name = models.CharField(max_length=100, verbose_name=\"Prénom\")\n    last_name = models.CharField(max_length=100, verbose_name=\"Nom\")\n    role = models.CharField(max_length=20, choices=ROLE_CHOICES, verbose_name=\"Rôle\")\n    job_title = models.CharField(max_length=100, blank=True, verbose_name=\"Titre/Fonction\")\n    department = models.CharField(max_length=100, blank=True, verbose_name=\"Service\")\n    \n    # Coordonnées\n    direct_phone = models.CharField(max_length=20, blank=True, verbose_name=\"Téléphone direct\")\n    mobile = models.CharField(max_length=20, blank=True, verbose_name=\"Mobile\")\n    email = models.EmailField(blank=True, verbose_name=\"Email\")\n    \n    # Préférences communication\n    preferred_contact = models.CharField(max_length=20, choices=[\n        ('EMAIL', 'Email'),\n        ('PHONE', 'Téléphone'),\n        ('MOBILE', 'Mobile'),\n    ], default='EMAIL')\n    \n    # Autorisations\n    can_approve_orders = models.BooleanField(default=False, verbose_name=\"Peut approuver commandes\")\n    can_receive_invoices = models.BooleanField(default=True, verbose_name=\"Reçoit les factures\")\n    can_receive_statements = models.BooleanField(default=False, verbose_name=\"Reçoit les relevés\")\n    \n    is_primary = models.BooleanField(default=False, verbose_name=\"Contact principal\")\n    is_active = models.BooleanField(default=True)\n    \n    class Meta:\n        db_table = 'customer_contacts'\n        verbose_name = \"Contact client\"\n        verbose_name_plural = \"Contacts clients\"\n    \n    def __str__(self):\n        return f\"{self.first_name} {self.last_name} ({self.customer.code})\"\n    \n    @property\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n\nclass CustomerDeliveryAddress(TimeStampedModel):\n    \"\"\"\n    Coordonnées multi-sites de livraison (EXF-CC-001)\n    \"\"\"\n    \n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='delivery_addresses')\n    \n    label = models.CharField(max_length=100, verbose_name=\"Libellé du site\")\n    \n    # Adresse complète\n    address_line1 = models.CharField(max_length=100, verbose_name=\"Ligne 1\")\n    address_line2 = models.CharField(max_length=100, blank=True, verbose_name=\"Ligne 2\")\n    city = models.CharField(max_length=100, verbose_name=\"Ville\")\n    region = models.CharField(max_length=100, blank=True, verbose_name=\"Région\")\n    postal_code = models.CharField(max_length=10, blank=True, verbose_name=\"Code postal\")\n    country = models.CharField(max_length=50, default=\"Cameroun\", verbose_name=\"Pays\")\n    \n    # Contact sur site\n    contact_person = models.CharField(max_length=100, blank=True, verbose_name=\"Contact sur site\")\n    phone = models.CharField(max_length=20, blank=True, verbose_name=\"Téléphone\")\n    email = models.EmailField(blank=True, verbose_name=\"Email\")\n    \n    # Instructions spéciales\n    delivery_instructions = models.TextField(blank=True, verbose_name=\"Instructions de livraison\")\n    access_instructions = models.TextField(blank=True, verbose_name=\"Instructions d'accès\")\n    \n    # Horaires\n    opening_hours = models.JSONField(default=dict, blank=True, verbose_name=\"Horaires d'ouverture\")\n    \n    # Géolocalisation\n    latitude = models.DecimalField(max_digits=10, decimal_places=8, null=True, blank=True)\n    longitude = models.DecimalField(max_digits=11, decimal_places=8, null=True, blank=True)\n    \n    is_default = models.BooleanField(default=False, verbose_name=\"Site par défaut\")\n    is_active = models.BooleanField(default=True)\n    \n    class Meta:\n        db_table = 'customer_delivery_addresses'\n        verbose_name = \"Adresse de livraison\"\n        verbose_name_plural = \"Adresses de livraison\"\n    \n    def __str__(self):\n        return f\"{self.customer.code} - {self.label}\"\n    \n    @property\n    def formatted_address(self):\n        lines = [self.address_line1]\n        if self.address_line2:\n            lines.append(self.address_line2)\n        \n        city_line = self.city\n        if self.postal_code:\n            city_line = f\"{self.postal_code} {self.city}\"\n        lines.append(city_line)\n        \n        if self.region:\n            lines.append(self.region)\n        \n        return \"\\n\".join(lines)\n\n\nclass CustomerDocument(TimeStampedModel):\n    \"\"\"\n    Documents légaux clients (EXF-CC-001)\n    Kbis, Attestations, etc.\n    \"\"\"\n    \n    DOCUMENT_TYPE_CHOICES = [\n        ('KBIS', 'Extrait Kbis'),\n        ('RCCM', 'RCCM'),\n        ('TAX_CERT', 'Attestation fiscale'),\n        ('VAT_CERT', 'Attestation TVA'),\n        ('INSURANCE', 'Attestation assurance'),\n        ('BANK_RIB', 'RIB'),\n        ('CONTRACT', 'Contrat cadre'),\n        ('ID_CARD', 'Pièce d\\'identité'),\n        ('OTHER', 'Autre'),\n    ]\n    \n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='documents')\n    \n    document_type = models.CharField(max_length=20, choices=DOCUMENT_TYPE_CHOICES)\n    title = models.CharField(max_length=200, verbose_name=\"Titre du document\")\n    description = models.TextField(blank=True, verbose_name=\"Description\")\n    \n    # Stockage du document\n    file_path = models.CharField(max_length=500, blank=True, verbose_name=\"Chemin fichier\")\n    file_size = models.PositiveIntegerField(null=True, blank=True, verbose_name=\"Taille (bytes)\")\n    file_type = models.CharField(max_length=10, blank=True, verbose_name=\"Type fichier\")\n    \n    # Métadonnées du document\n    document_date = models.DateField(verbose_name=\"Date du document\")\n    expiry_date = models.DateField(null=True, blank=True, verbose_name=\"Date d'expiration\")\n    reference_number = models.CharField(max_length=100, blank=True, verbose_name=\"Numéro de référence\")\n    \n    # Validation et conformité\n    is_verified = models.BooleanField(default=False, verbose_name=\"Vérifié\")\n    verified_by = models.ForeignKey(\n        'auth.User', on_delete=models.SET_NULL, null=True, blank=True,\n        verbose_name=\"Vérifié par\"\n    )\n    verification_date = models.DateTimeField(null=True, blank=True)\n    \n    is_expired = models.BooleanField(default=False, verbose_name=\"Expiré\")\n    \n    class Meta:\n        db_table = 'customer_documents'\n        ordering = ['-document_date']\n        verbose_name = \"Document client\"\n        verbose_name_plural = \"Documents clients\"\n    \n    def __str__(self):\n        return f\"{self.customer.code} - {self.title}\"\n    \n    def save(self, *args, **kwargs):\n        # Vérification automatique expiration\n        if self.expiry_date and self.expiry_date <= date.today():\n            self.is_expired = True\n        \n        super().save(*args, **kwargs)\n\n\nclass CustomerPaymentPromise(TimeStampedModel):\n    \"\"\"\n    Gestion des Promesses de Paiement (EXF-CC-003)\n    \"\"\"\n    \n    STATUS_CHOICES = [\n        ('PENDING', 'En attente'),\n        ('RESPECTED', 'Respectée'),\n        ('BROKEN', 'Non respectée'),\n        ('PARTIAL', 'Partiellement respectée'),\n        ('CANCELLED', 'Annulée'),\n    ]\n    \n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='payment_promises')\n    \n    # Références\n    promise_reference = models.CharField(max_length=50, verbose_name=\"Référence promesse\")\n    related_invoice = models.CharField(max_length=50, blank=True, verbose_name=\"Facture concernée\")\n    \n    # Engagement du client\n    promised_amount = models.DecimalField(\n        max_digits=20, decimal_places=2, verbose_name=\"Montant promis\"\n    )\n    promised_date = models.DateField(verbose_name=\"Date promise\")\n    payment_method = models.CharField(\n        max_length=20, choices=Customer.PAYMENT_METHOD_CHOICES,\n        verbose_name=\"Mode de paiement promis\"\n    )\n    \n    # Suivi de la promesse\n    actual_amount = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"Montant réellement payé\"\n    )\n    actual_payment_date = models.DateField(null=True, blank=True, verbose_name=\"Date paiement réel\")\n    \n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='PENDING')\n    \n    # Métadonnées\n    notes = models.TextField(blank=True, verbose_name=\"Notes\")\n    created_by = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True)\n    \n    # Suivi automatique\n    reminder_sent = models.BooleanField(default=False, verbose_name=\"Rappel envoyé\")\n    reminder_date = models.DateTimeField(null=True, blank=True)\n    \n    class Meta:\n        db_table = 'customer_payment_promises'\n        ordering = ['-promised_date']\n        indexes = [\n            models.Index(fields=['customer', 'status']),\n            models.Index(fields=['-promised_date']),\n        ]\n        verbose_name = \"Promesse de paiement\"\n        verbose_name_plural = \"Promesses de paiement\"\n    \n    def __str__(self):\n        return f\"{self.customer.code} - {self.promised_amount} - {self.promised_date}\"\n    \n    @property\n    def days_overdue(self):\n        \"\"\"Nombre de jours de retard sur la promesse\"\"\"\n        if self.status in ['RESPECTED', 'CANCELLED']:\n            return 0\n        \n        if self.promised_date < date.today():\n            return (date.today() - self.promised_date).days\n        return 0\n    \n    @property\n    def respect_rate(self):\n        \"\"\"Taux de respect de la promesse en %\"\"\"\n        if self.promised_amount == 0:\n            return Decimal('0')\n        \n        return (self.actual_amount / self.promised_amount * 100).quantize(Decimal('0.1'))\n    \n    def check_fulfillment(self):\n        \"\"\"\n        Vérifie automatiquement si la promesse a été tenue\n        \"\"\"\n        if self.status != 'PENDING':\n            return\n        \n        if self.actual_payment_date:\n            if self.actual_amount >= self.promised_amount:\n                self.status = 'RESPECTED'\n            elif self.actual_amount > 0:\n                self.status = 'PARTIAL'\n            \n            self.save(update_fields=['status'])\n        \n        elif self.promised_date < date.today():\n            self.status = 'BROKEN'\n            self.save(update_fields=['status'])\n\n\nclass CustomerReminderHistory(TimeStampedModel):\n    \"\"\"\n    Historique des Relances Multi-Niveaux (EXF-CC-003)\n    \"\"\"\n    \n    REMINDER_LEVEL_CHOICES = [\n        ('LEVEL_1', 'Niveau 1 - Rappel courtois (J+5)'),\n        ('LEVEL_2', 'Niveau 2 - Email + SMS ferme (J+15)'),\n        ('LEVEL_3', 'Niveau 3 - Lettre recommandée (J+30)'),\n        ('LEVEL_4', 'Niveau 4 - Mise en demeure (J+45)'),\n        ('LEVEL_5', 'Niveau 5 - Transfert contentieux (J+60)'),\n    ]\n    \n    CHANNEL_CHOICES = [\n        ('EMAIL', 'Email'),\n        ('SMS', 'SMS'),\n        ('PHONE', 'Appel téléphonique'),\n        ('POST', 'Courrier postal'),\n        ('REGISTERED', 'Lettre recommandée'),\n        ('LEGAL', 'Procédure légale'),\n    ]\n    \n    STATUS_CHOICES = [\n        ('SENT', 'Envoyée'),\n        ('DELIVERED', 'Livrée'),\n        ('READ', 'Lue'),\n        ('RESPONDED', 'Réponse reçue'),\n        ('FAILED', 'Échec envoi'),\n    ]\n    \n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, related_name='reminders')\n    \n    # Classification de la relance\n    reminder_level = models.CharField(max_length=10, choices=REMINDER_LEVEL_CHOICES)\n    channel = models.CharField(max_length=20, choices=CHANNEL_CHOICES)\n    \n    # Contenu\n    subject = models.CharField(max_length=200, verbose_name=\"Objet\")\n    message = models.TextField(verbose_name=\"Message\")\n    \n    # Cibles\n    target_contact = models.ForeignKey(\n        CustomerContact, on_delete=models.SET_NULL, null=True, blank=True,\n        verbose_name=\"Contact ciblé\"\n    )\n    target_email = models.EmailField(blank=True)\n    target_phone = models.CharField(max_length=20, blank=True)\n    \n    # Suivi\n    sent_date = models.DateTimeField(auto_now_add=True)\n    delivery_date = models.DateTimeField(null=True, blank=True)\n    read_date = models.DateTimeField(null=True, blank=True)\n    response_date = models.DateTimeField(null=True, blank=True)\n    \n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='SENT')\n    \n    # Résultats\n    response_received = models.BooleanField(default=False)\n    payment_promised = models.BooleanField(default=False)\n    promise_date = models.DateField(null=True, blank=True)\n    promise_amount = models.DecimalField(\n        max_digits=20, decimal_places=2, null=True, blank=True\n    )\n    \n    # Métadonnées\n    sent_by = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True)\n    \n    class Meta:\n        db_table = 'customer_reminder_history'\n        ordering = ['-sent_date']\n        indexes = [\n            models.Index(fields=['customer', '-sent_date']),\n            models.Index(fields=['reminder_level']),\n        ]\n        verbose_name = \"Historique relance\"\n        verbose_name_plural = \"Historique relances\"\n    \n    def __str__(self):\n        return f\"{self.customer.code} - {self.reminder_level} - {self.sent_date}\"\n\n\nclass CustomerAnalytics(TimeStampedModel):\n    \"\"\"\n    Analytics et métriques clients\n    Historique complet de la relation (EXF-CC-001)\n    \"\"\"\n    \n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    customer = models.OneToOneField(\n        Customer, on_delete=models.CASCADE, related_name='analytics'\n    )\n    \n    # Métriques calculées automatiquement\n    total_orders_count = models.PositiveIntegerField(default=0, verbose_name=\"Nombre total commandes\")\n    total_invoices_count = models.PositiveIntegerField(default=0, verbose_name=\"Nombre total factures\")\n    total_amount_invoiced = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"Montant total facturé\"\n    )\n    total_amount_paid = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"Montant total payé\"\n    )\n    \n    # Moyennes et tendances\n    average_order_amount = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"Montant moyen commande\"\n    )\n    average_payment_delay = models.DecimalField(\n        max_digits=10, decimal_places=1, default=Decimal('0'),\n        verbose_name=\"Délai moyen paiement (jours)\"\n    )\n    \n    # Taux de performance\n    on_time_payment_rate = models.DecimalField(\n        max_digits=5, decimal_places=2, default=Decimal('100'),\n        verbose_name=\"Taux paiement à temps (%)\"\n    )\n    promise_respect_rate = models.DecimalField(\n        max_digits=5, decimal_places=2, default=Decimal('100'),\n        verbose_name=\"Taux respect promesses (%)\"\n    )\n    \n    # Fréquence des commandes\n    last_12m_orders = models.PositiveIntegerField(default=0, verbose_name=\"Commandes 12 derniers mois\")\n    last_12m_amount = models.DecimalField(\n        max_digits=20, decimal_places=2, default=Decimal('0'),\n        verbose_name=\"CA 12 derniers mois\"\n    )\n    \n    # Tendances (calcul automatique)\n    trend_orders = models.CharField(max_length=10, choices=[\n        ('UP', 'Croissante'),\n        ('STABLE', 'Stable'),\n        ('DOWN', 'Décroissante'),\n    ], default='STABLE', verbose_name=\"Tendance commandes\")\n    \n    trend_amount = models.CharField(max_length=10, choices=[\n        ('UP', 'Croissante'),\n        ('STABLE', 'Stable'),\n        ('DOWN', 'Décroissante'),\n    ], default='STABLE', verbose_name=\"Tendance montants\")\n    \n    # Dernière mise à jour\n    last_calculation = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'customer_analytics'\n        verbose_name = \"Analytics client\"\n        verbose_name_plural = \"Analytics clients\"\n    \n    def __str__(self):\n        return f\"Analytics {self.customer.code}\"\n    \n    def refresh_metrics(self):\n        \"\"\"\n        Recalcule toutes les métriques du client\n        Performance optimisée avec requêtes groupées\n        \"\"\"\n        from django.db.models import Sum, Count, Avg\n        from apps.accounting.models import JournalEntryLine\n        \n        if not self.customer.account:\n            return\n        \n        # Période de calcul (12 mois)\n        one_year_ago = date.today() - timedelta(days=365)\n        \n        # Requêtes optimisées groupées\n        transactions = JournalEntryLine.objects.filter(\n            account=self.customer.account,\n            third_party=self.customer,\n            entry__is_validated=True,\n            entry__entry_date__gte=one_year_ago\n        )\n        \n        # Calculs d'agrégats\n        stats = transactions.aggregate(\n            total_invoiced=Sum('debit_amount') or Decimal('0'),\n            total_paid=Sum('credit_amount') or Decimal('0'),\n            invoice_count=Count('id', distinct=True),\n            avg_amount=Avg('debit_amount') or Decimal('0')\n        )\n        \n        # Mise à jour des métriques\n        self.last_12m_amount = stats['total_invoiced']\n        self.total_amount_invoiced = stats['total_invoiced']\n        self.total_amount_paid = stats['total_paid']\n        self.total_invoices_count = stats['invoice_count']\n        self.average_order_amount = stats['avg_amount']\n        \n        # Calcul du taux de paiement à temps\n        on_time_payments = transactions.filter(\n            is_reconciled=True,\n            reconciliation_date__lte=F('entry__entry_date') + timedelta(days=self.customer.payment_terms)\n        ).count()\n        \n        total_payments = transactions.filter(is_reconciled=True).count()\n        \n        if total_payments > 0:\n            self.on_time_payment_rate = (on_time_payments / total_payments * 100)\n        \n        self.save()